# 18. MAPA DE CALOR INTERPOLADO (CONTINUO)
# ==============================================================================
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía sobre Venezuela
grilla <- st_make_grid(mapa_riesgo_final, n = c(200, 200), what = "centers") %>%
st_as_sf() %>%
st_join(mapa_riesgo_final) # Recortar con la forma de Vzla
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# 1. Cargar librerías
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
pacman::p_load(tidyverse, sf, geodata, viridis, scales, lubridate, zoo, stringi, janitor, cluster, factoextra, spdep, gstat, raster)
# Asegurar carga explicita de gstat por si pacman falla silenciosamente
if (!requireNamespace("gstat", quietly = TRUE)) install.packages("gstat")
library(gstat)
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía sobre Venezuela
grilla <- st_make_grid(mapa_riesgo_final, n = c(200, 200), what = "centers") %>%
st_as_sf() %>%
st_join(mapa_riesgo_final) # Recortar con la forma de Vzla
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla (Puede tardar unos segundos)
interpolacion <- predict(modelo_idw, grilla)
# 4. Visualizar como superficie continua
plot_heatmap <- ggplot() +
geom_sf(data = interpolacion, aes(color = var1.pred), size = 0.5) +
scale_color_viridis_c(option = "inferno", name = "Intensidad de Riesgo") +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano",
caption = "Muestra zonas de influencia más allá de los límites municipales") +
theme_void()
print(plot_heatmap)
# 4. Visualizar como superficie continua
plot_heatmap <- ggplot() +
geom_sf(data = interpolacion, aes(color = var1.pred), size = 0.5) +
scale_color_viridis_c(option = "inferno", name = "Intensidad de Riesgo") +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano",
caption = "Muestra zonas de influencia más allá de los límites municipales") +
theme_void()
print(plot_heatmap)
message("Mapa de calor generado exitosamente.")
} else {
message("\n--- ATENCIÓN: PAQUETE INLA NO DETECTADO ---")
message("El error de instalación se debe a dependencias de Bioconductor.")
message("Por favor, copia y ejecuta MANUALMENTE las líneas comentadas al inicio de la Sección 16.")
# Asegurar carga explicita de gstat por si pacman falla silenciosamente
if (!requireNamespace("gstat", quietly = TRUE)) install.packages("gstat")
library(gstat)
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía sobre Venezuela
grilla <- st_make_grid(mapa_riesgo_final, n = c(200, 200), what = "centers") %>%
st_as_sf() %>%
st_join(mapa_riesgo_final) # Recortar con la forma de Vzla
# 3. Interpolación IDW (Inverse Distance Weighting)
# Predecir el valor de Riesgo en cada punto de la grilla basado en los vecinos
# idp = 2.0 es el estándar (peso decae con el cuadrado de la distancia)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla (Puede tardar unos segundos)
interpolacion <- predict(modelo_idw, grilla)
# 4. Visualizar como superficie continua
plot_heatmap <- ggplot() +
geom_sf(data = interpolacion, aes(color = var1.pred), size = 0.5) +
scale_color_viridis_c(option = "inferno", name = "Intensidad de Riesgo") +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano",
caption = "Muestra zonas de influencia más allá de los límites municipales") +
theme_void()
print(plot_heatmap)
message("Mapa de calor generado exitosamente.")
} else {
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía (Cuadrada/Bounding Box)
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(150, 150), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía (Cuadrada/Bounding Box)
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(150, 150), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# 5. Visualizar como superficie continua
plot_heatmap <- ggplot() +
geom_sf(data = interpolacion, aes(color = var1.pred), size = 0.8) + # size ajustado para rellenar
scale_color_viridis_c(option = "inferno", name = "Riesgo Continuo") +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Recortada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
message("Mapa de calor generado exitosamente.")
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# Convertir a coordenadas XY para usar geom_tile (que crea superficies continuas)
coords_interp <- st_coordinates(interpolacion)
data_heatmap <- interpolacion %>%
bind_cols(as_tibble(coords_interp)) %>%
rename(lon = X, lat = Y, Riesgo = var1.pred)
# 5. Visualizar como SUPERFICIE CONTINUA (Raster)
plot_heatmap <- ggplot() +
# Usamos geom_tile en lugar de geom_sf para crear una superficie sólida
geom_tile(data = data_heatmap, aes(x = lon, y = lat, fill = Riesgo)) +
# Añadimos el contorno de los estados para referencia
geom_sf(data = mapa_vzla_muni %>% group_by(EST) %>% summarise(),
fill = NA, color = "white", size = 0.1, alpha = 0.3) +
scale_fill_viridis_c(
option = "inferno",
name = "Riesgo Continuo",
na.value = "transparent"
) +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Superficie Suavizada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía de ALTA RESOLUCIÓN (300x300)
# Mayor resolución = superficie más suave
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(900, 900), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# Convertir a coordenadas XY para usar geom_tile (que crea superficies continuas)
coords_interp <- st_coordinates(interpolacion)
data_heatmap <- interpolacion %>%
bind_cols(as_tibble(coords_interp)) %>%
rename(lon = X, lat = Y, Riesgo = var1.pred)
# 5. Visualizar como SUPERFICIE CONTINUA (Raster)
plot_heatmap <- ggplot() +
# Usamos geom_tile en lugar de geom_sf para crear una superficie sólida
geom_tile(data = data_heatmap, aes(x = lon, y = lat, fill = Riesgo)) +
# Añadimos el contorno de los estados para referencia
geom_sf(data = mapa_vzla_muni %>% group_by(EST) %>% summarise(),
fill = NA, color = "white", size = 0.1, alpha = 0.3) +
scale_fill_viridis_c(
option = "inferno",
name = "Riesgo Continuo",
na.value = "transparent"
) +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Superficie Suavizada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía de ALTA RESOLUCIÓN (300x300)
# Mayor resolución = superficie más suave
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(900, 900), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# Convertir a coordenadas XY para usar geom_tile (que crea superficies continuas)
coords_interp <- st_coordinates(interpolacion)
data_heatmap <- interpolacion %>%
bind_cols(as_tibble(coords_interp)) %>%
rename(lon = X, lat = Y, Riesgo = var1.pred)
# 5. Visualizar como SUPERFICIE CONTINUA (Raster)
plot_heatmap <- ggplot() +
# Usamos geom_tile en lugar de geom_sf para crear una superficie sólida
geom_tile(data = data_heatmap, aes(x = lon, y = lat, fill = Riesgo)) +
# Añadimos el contorno de los estados para referencia
geom_sf(data = mapa_vzla_muni %>% group_by(EST) %>% summarise(),
fill = NA, color = "white", size = 0.1, alpha = 0.3) +
# CAMBIO DE PALETA: Azul (Bajo) -> Blanco (Medio) -> Rojo (Alto)
scale_fill_gradientn(
colors = c("#313695", "#4575b4", "#e0f3f8", "#fee090", "#f46d43", "#a50026"),
values = scales::rescale(c(min(data_heatmap$Riesgo), 1, max(data_heatmap$Riesgo))), # Centrar blanco en 1 (Riesgo Promedio)
name = "Riesgo Continuo",
na.value = "transparent"
) +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Superficie Suavizada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)\nAzul: Bajo Riesgo | Rojo: Alto Riesgo") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía de ALTA RESOLUCIÓN (300x300)
# Mayor resolución = superficie más suave
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(300, 300), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
message("\n--- GENERANDO MAPA DE CALOR INTERPOLADO (IDW) ---")
# 1. Convertir Polígonos a Puntos (Centroides de Riesgo)
puntos_riesgo <- st_centroid(mapa_riesgo_final)
# 2. Crear una grilla vacía de ALTA RESOLUCIÓN (300x300)
# Mayor resolución = superficie más suave
grilla_total <- st_make_grid(mapa_riesgo_final, n = c(900, 900), what = "centers") %>%
st_as_sf()
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# Convertir a coordenadas XY para usar geom_tile (que crea superficies continuas)
coords_interp <- st_coordinates(interpolacion)
data_heatmap <- interpolacion %>%
bind_cols(as_tibble(coords_interp)) %>%
rename(lon = X, lat = Y, Riesgo = var1.pred)
# 5. Visualizar como SUPERFICIE CONTINUA (Raster)
plot_heatmap <- ggplot() +
# Usamos geom_tile en lugar de geom_sf para crear una superficie sólida
geom_tile(data = data_heatmap, aes(x = lon, y = lat, fill = Riesgo)) +
# Añadimos el contorno de los estados para referencia
geom_sf(data = mapa_vzla_muni %>% group_by(EST) %>% summarise(),
fill = NA, color = "white", size = 0.1, alpha = 0.3) +
# CAMBIO DE PALETA: Gradiente divergente LOGARÍTMICO
# Esto garantiza que el centro (Riesgo 1) sea neutro y la transición sea simétrica
scale_fill_gradient2(
low = "#313695",    # Azul (Riesgo Bajo < 1)
mid = "#ffffbf",    # Amarillo Pálido (Riesgo Promedio ~ 1)
high = "#a50026",   # Rojo (Riesgo Alto > 1)
midpoint = 0,       # En escala Log, el centro es log(1) = 0
trans = "log",      # Clave: Suaviza la transición entre valores bajos y altos
breaks = c(0.5, 0.8, 1, 1.5, 3), # Cortes manuales para entender la leyenda
name = "Riesgo Continuo",
na.value = "transparent"
) +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Superficie Suavizada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)\nAzul: Bajo Riesgo | Rojo: Alto Riesgo") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
# 19. MODELADO PREDICTIVO: PROYECCIÓN ESPACIO-TEMPORAL BAYESIANA (INLA)
# ==============================================================================
message("\n--- GENERANDO PROYECCIONES FUTURAS 2017-2021 (FORECASTING BAYESIANO) ---")
message("Aplicando la lógica 'Lee-Carter Espacial':")
message("1. Estructura Espacial (Vecinos) + 2. Tendencia Temporal (Inercia) -> Predicción")
# A. Crear Estructura de Datos Futuros (2017-2021)
future_years <- 2017:2021
tasa_crecimiento_pob <- 0.016
# Generamos la cuadrícula de municipios x años futuros
df_future <- expand_grid(
EST = unique(df_final$EST),
Muni_Clean = unique(df_final$Muni_Clean),
ano = future_years
) %>%
# Cruzamos con la población base de 2016 para proyectarla
left_join(df_poblacion_panel %>% filter(ano == 2016) %>% select(EST, Muni_Clean, Pob_2016 = Poblacion),
by = c("EST", "Muni_Clean")) %>%
mutate(
# Proyectar población 2017-2021
Poblacion = Pob_2016 * (1 + tasa_crecimiento_pob)^(ano - 2016),
# Variables clave para INLA
Total_Muertes = NA, # <--- ESTO ES LO QUE INLA VA A PREDECIR
ID_Tiempo = ano - 1995, # Continúa la secuencia temporal (22, 23, 24...)
Esperados = NA # Se calculará al unir
) %>%
select(-Pob_2016)
# 19. MODELADO PREDICTIVO: PROYECCIÓN ESPACIO-TEMPORAL BAYESIANA (INLA)
# ==============================================================================
message("\n--- GENERANDO PROYECCIONES FUTURAS 2017-2021 (FORECASTING BAYESIANO) ---")
message("Aplicando la lógica 'Lee-Carter Espacial':")
message("1. Estructura Espacial (Vecinos) + 2. Tendencia Temporal (Inercia) -> Predicción")
# A. Crear Estructura de Datos Futuros (2017-2021)
future_years <- 2017:2021
tasa_crecimiento_pob <- 0.016
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final %>% dplyr::select(EST)) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# Generamos la cuadrícula de municipios x años futuros
df_future <- expand_grid(
EST = unique(df_final$EST),
Muni_Clean = unique(df_final$Muni_Clean),
ano = future_years
) %>%
# Cruzamos con la población base de 2016 para proyectarla
left_join(df_poblacion_panel %>% filter(ano == 2016) %>% select(EST, Muni_Clean, Pob_2016 = Poblacion),
by = c("EST", "Muni_Clean")) %>%
mutate(
# Proyectar población 2017-2021
Poblacion = Pob_2016 * (1 + tasa_crecimiento_pob)^(ano - 2016),
# Variables clave para INLA
Total_Muertes = NA, # <--- ESTO ES LO QUE INLA VA A PREDECIR
ID_Tiempo = ano - 1995, # Continúa la secuencia temporal (22, 23, 24...)
Esperados = NA # Se calculará al unir
) %>%
select(-Pob_2016)
# 3. RECORTAR LA GRILLA (Paso clave para evitar el cuadrado)
# Solo mantenemos los puntos que caen DENTRO de los municipios de Venezuela
# CORRECCIÓN: Usar dplyr::select explícitamente para evitar conflicto con paquete raster
grilla_recortada <- grilla_total %>%
st_join(mapa_riesgo_final[, "EST"]) %>%
filter(!is.na(EST))
message("Interpolando riesgo sobre ", nrow(grilla_recortada), " puntos de grilla...")
# 4. Interpolación IDW (Inverse Distance Weighting)
# Usamos gstat para el modelo
modelo_idw <- gstat(formula = Riesgo_Espacial ~ 1, locations = puntos_riesgo,
set = list(idp = 2.0))
# Predecir sobre la grilla recortada
interpolacion <- predict(modelo_idw, grilla_recortada)
# Convertir a coordenadas XY para usar geom_tile (que crea superficies continuas)
coords_interp <- st_coordinates(interpolacion)
data_heatmap <- interpolacion %>%
bind_cols(as_tibble(coords_interp)) %>%
rename(lon = X, lat = Y, Riesgo = var1.pred)
# 5. Visualizar como SUPERFICIE CONTINUA (Raster)
plot_heatmap <- ggplot() +
# Usamos geom_tile en lugar de geom_sf para crear una superficie sólida
geom_tile(data = data_heatmap, aes(x = lon, y = lat, fill = Riesgo)) +
# Añadimos el contorno de los estados para referencia
geom_sf(data = mapa_vzla_muni %>% group_by(EST) %>% summarise(),
fill = NA, color = "white", size = 0.1, alpha = 0.3) +
# CAMBIO DE PALETA: Gradiente divergente LOGARÍTMICO
# Esto garantiza que el centro (Riesgo 1) sea neutro y la transición sea simétrica
scale_fill_gradient2(
low = "#313695",    # Azul (Riesgo Bajo < 1)
mid = "#ffffbf",    # Amarillo Pálido (Riesgo Promedio ~ 1)
high = "#a50026",   # Rojo (Riesgo Alto > 1)
midpoint = 0,       # En escala Log, el centro es log(1) = 0
trans = "log",      # Clave: Suaviza la transición entre valores bajos y altos
breaks = c(0.5, 0.8, 1, 1.5, 3), # Cortes manuales para entender la leyenda
name = "Riesgo Continuo",
na.value = "transparent"
) +
labs(title = "Mapa de Calor Continuo de Mortalidad",
subtitle = "Interpolación IDW del Riesgo Bayesiano (Superficie Suavizada)",
caption = "Interpolación sobre territorio nacional (excluye mar/fronteras)\nAzul: Bajo Riesgo | Rojo: Alto Riesgo") +
theme_void() +
theme(legend.position = "right")
print(plot_heatmap)
message("Mapa de calor generado exitosamente.")
# 19. MODELADO PREDICTIVO: PROYECCIÓN ESPACIO-TEMPORAL BAYESIANA (INLA)
# ==============================================================================
message("\n--- GENERANDO PROYECCIONES FUTURAS 2017-2021 (FORECASTING BAYESIANO) ---")
message("Aplicando la lógica 'Lee-Carter Espacial':")
message("1. Estructura Espacial (Vecinos) + 2. Tendencia Temporal (Inercia) -> Predicción")
# A. Crear Estructura de Datos Futuros (2017-2021)
future_years <- 2017:2021
tasa_crecimiento_pob <- 0.016
# Generamos la cuadrícula de municipios x años futuros
df_future <- expand_grid(
EST = unique(df_final$EST),
Muni_Clean = unique(df_final$Muni_Clean),
ano = future_years
) %>%
# Cruzamos con la población base de 2016 para proyectarla
left_join(df_poblacion_panel %>% filter(ano == 2016) %>% select(EST, Muni_Clean, Pob_2016 = Poblacion),
by = c("EST", "Muni_Clean")) %>%
mutate(
# Proyectar población 2017-2021
Poblacion = Pob_2016 * (1 + tasa_crecimiento_pob)^(ano - 2016),
# Variables clave para INLA
Total_Muertes = NA, # <--- ESTO ES LO QUE INLA VA A PREDECIR
ID_Tiempo = ano - 1995, # Continúa la secuencia temporal (22, 23, 24...)
Esperados = NA # Se calculará al unir
) %>%
select(-Pob_2016)
# 19. MODELADO PREDICTIVO: PROYECCIÓN ESPACIO-TEMPORAL BAYESIANA (INLA)
# ==============================================================================
message("\n--- GENERANDO PROYECCIONES FUTURAS 2017-2021 (FORECASTING BAYESIANO) ---")
message("Aplicando la lógica 'Lee-Carter Espacial':")
message("1. Estructura Espacial (Vecinos) + 2. Tendencia Temporal (Inercia) -> Predicción")
# A. Crear Estructura de Datos Futuros (2017-2021)
future_years <- 2017:2021
tasa_crecimiento_pob <- 0.016
# Generamos la cuadrícula de municipios x años futuros
df_future <- expand_grid(
EST = unique(df_final$EST),
Muni_Clean = unique(df_final$Muni_Clean),
ano = future_years
) %>%
# Cruzamos con la población base de 2016 para proyectarla
# CORRECCIÓN: Usar dplyr::select para evitar conflictos con raster
left_join(df_poblacion_panel %>% filter(ano == 2016) %>% dplyr::select(EST, Muni_Clean, Pob_2016 = Poblacion),
by = c("EST", "Muni_Clean")) %>%
mutate(
# Proyectar población 2017-2021
Poblacion = Pob_2016 * (1 + tasa_crecimiento_pob)^(ano - 2016),
# Variables clave para INLA
Total_Muertes = NA, # <--- ESTO ES LO QUE INLA VA A PREDECIR
ID_Tiempo = ano - 1995, # Continúa la secuencia temporal (22, 23, 24...)
Esperados = NA # Se calculará al unir
) %>%
# CORRECCIÓN: Usar dplyr::select
dplyr::select(-Pob_2016)
# Unir Historia + Futuro
# Necesitamos recalcular IDs de Área para que coincidan
unique_areas <- unique(paste(mapa_ordenado$EST, mapa_ordenado$Muni_Clean))
df_forecast_inla <- bind_rows(
df_final %>% mutate(Tipo = "Historia"),
df_future %>% mutate(Tipo = "Prediccion")
) %>%
arrange(EST, Muni_Clean, ano) %>%
mutate(
ID_Area = as.numeric(factor(paste(EST, Muni_Clean), levels = unique_areas)),
# Recalcular Esperados globales para el offset (usando tasa histórica promedio)
Esperados = ifelse(is.na(Esperados), Poblacion * tasa_global_promedio, Esperados)
) %>%
filter(!is.na(ID_Area))
message("Datos preparados: ", nrow(df_forecast_inla), " registros (Historia + Futuro).")
# B. Ejecutar Modelo INLA con Datos Faltantes (NA)
# INLA imputará los NAs basándose en la correlación espacio-temporal aprendida
message("Re-entrenando INLA para predicción (puede tardar 1-2 mins)...")
formula_forecast <- Total_Muertes ~ 1 +
f(ID_Area, model = "bym", graph = graph_file_safe) +
f(ID_Tiempo, model = "rw1")
# link=1 le dice a INLA que calcule los fitted values en la escala de respuesta (muertes)
resultado_forecast <- inla(formula_forecast,
family = "poisson",
data = df_forecast_inla,
E = Esperados,
control.predictor = list(compute = TRUE, link = 1),
num.threads = 1,
verbose = FALSE)
# C. Extraer Predicciones
message("Extrayendo predicciones...")
# Los valores ajustados (fitted.values) contienen la media posterior
predicciones <- df_forecast_inla %>%
mutate(
Muertes_Predichas = resultado_forecast$summary.fitted.values$mean,
Limite_Inf = resultado_forecast$summary.fitted.values$`0.025quant`,
Limite_Sup = resultado_forecast$summary.fitted.values$`0.975quant`,
Tasa_Predicha = (Muertes_Predichas / Poblacion) * 10000
) %>%
filter(Tipo == "Prediccion")
# D. Visualizar la Proyección (Mapa 2021)
mapa_2021 <- mapa_vzla_muni %>%
inner_join(predicciones %>% filter(ano == 2021), by = c("EST", "Muni_Clean"))
plot_forecast_map <- ggplot(mapa_2021) +
geom_sf(aes(fill = Tasa_Predicha), color = NA) +
scale_fill_viridis_c(option = "magma", direction = -1, name = "Tasa Predicha\n(2021)") +
labs(title = "Proyección de Mortalidad 2021 (Modelo Espacio-Temporal)",
subtitle = "Estimación Bayesiana basada en vecindad y tendencia histórica",
caption = "Proyección asumiendo continuidad de patrones 1996-2016") +
theme_void() +
theme(legend.position = "right")
print(plot_forecast_map)
